<!doctype html>
<メタ文字セット="utf-8">
<meta name="viewport" content="width=デバイス幅、初期スケール=1、ビューポートフィット=カバー">
<title>コンパイルピッカー</title>
<スタイル>
  :root{--bg:#0d1117;--card:#111827;--line:#263244;--fg:#e6edf3;--muted:#9aa6b2;--link:#58a6ff}
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,"Noto Sans JP","Yu Gothic",Meiryo,Arial,sans-serif;background:var(--bg);color:var(--fg);margin:24px}
  h1{フォントサイズ:20px;マージン:0 0 10px}
  .grid{display:grid;grid-template-columns:1fr 1fr;gap:16px}
  .card{background:var(--card);border:1px solid var(--line);border-radius:12px;padding:12px}
  .row{display:flex;gap:8px;flex-wrap:wrap;margin:8px 0}
  テキストエリア{幅:100%;最小高さ:120px;背景:#0b1220;色:var(--fg);境界線:1px実線var(--line);境界線の半径:10px;パディング:8px;行の高さ:1.4;フォントサイズ:16px}
  input[type="number"], select{background:#0b1220;color:var(--fg);border:1px solid var(--line);border-radius:8px;padding:6px 8px;font-size:16px}
  入力[type="number"]{width:92px}
  ボタン{background:#1f2937;border:1px solid var(--line);color:var(--fg);padding:12px 14px;border-radius:12px;cursor:pointer;font-weight:700;min-height:48px;font-size:16px}
  ボタン:ホバー{背景:#263244}
  ボタン:アクティブ{transform:translateY(1px);フィルター:明るさ(1.05)}
  .result{white-space:pre-wrap;background:#0b1220;border:1px dashed var(--line);border-radius:10px;padding:10px;min-height:120px;margin-top:8px}
  .small{color:var(--muted);フォントサイズ:12px}
  .pill{display:inline-block;padding:4px 8px;border:1px solid var(--line);border-radius:999px;margin:4px 6px 0 0}
  .sticky-actions{
    位置: スティッキー; 下部: 0; 表示: フレックス; ギャップ: 8px;
    padding:10px calc(10px + env(セーフエリアインセット右)) calc(10px + env(セーフエリアインセット下部)) calc(10px + env(セーフエリアインセット左));
    背景: rgba(13,17,23,.8); 背景フィルター: ぼかし(8px); 上境界線: 1px 実線 var(--line); z-index:50
  }
  .sticky-actions ボタン{flex:1}
  @media (最大幅: 640px){
    .grid{グリッドテンプレート列:1fr;ギャップ:12px}
    .row{ギャップ:6px}
    .row > ボタン{flex:1}
    テキストエリア{最小高さ:140px}
  }
  フッター{margin-top:30px;text-align:center;color:var(--muted);font-size:12px}
  a{color:var(--link);テキスト装飾:なし}
</スタイル>

<h1>コンパイルピッカー</h1>

<div class="grid">
  <!-- ① 順位：ランダム優先 + Aux1恩恵 + P1/P2設定 -->

  <div class="card" style="grid-column:1 / -1">
    <div class="row">
      <button id="draftRandom">ランダム P1vsP2</button>
      <button id="pick3">ランダム3枚</button>
    </div>

    <div class="row">
      <button id="draftRatio">レシオP1vsP2</button>
      <button id="pickRatioBuild">レシオ3枚</button>
    </div>
    <div class="row">
      <label class="small">枚数
        <input type="number" id="cnt" value="3" min="2" max="6" inputmode="numeric">
      </ラベル>
    </div>

    <!-- P1/P2 それぞれの最小/最大 -->
    <span class="small" style="margin-left:8px">P1:</span>
    <label class="small">最小値 <input type="number" id="p1Min" value="7" inputmode="numeric"></label>
    <label class="small">最大 <input type="number" id="p1Max" value="8" inputmode="numeric"></label>

    <span class="small" style="margin-left:8px">P2:</span>
    <label class="small">最小値 <input type="number" id="p2Min" value="7" inputmode="numeric"></label>
    <label class="small">最大 <input type="number" id="p2Max" value="8" inputmode="numeric"></label>

    <!-- 構築で使う設定の選択 -->
    <label class="small" style="margin-left:auto;">レシオ3枚の判定
      <select id="buildSide">
        <option value="P1">P1 の設定</option>
        <option value="P2">P2 の設定</option>
      </選択>
    </ラベル>
    <label class="small" style="display:flex;align-items:center;gap:6px;margin-left:auto;">
      <input type="checkbox" id="auxToggle"> Aux1（HATE/LOVE/APATHY）を感謝
    </ラベル>

    <div id="out" class="result" aria-live="polite"></div>
    <!-- 共有ボタン行（動的表示） -->
    <div id="shareRow" class="row" style="justify-content:flex-end; display:none;">
      <button id="shareBtn">共有</button>
      <button id="copyBtn">コピー</button>
    </div>

    <!-- 下部アクション（親指用） -->
    <div class="sticky-actions">
      <button id="runDraftRandom">ランダムドラフト</button>
      <button id="runDraftRatio">レシオドラフト</button>
      <button id="runBuild">レシオ構築</button>
    </div>
  </div>

  <!-- ② 中段：レシオ設定 -->
  <div class="card">
    <div class="small">レシオ（初期値＝あなたの設定／0許可）</div>
    <textarea id="ratioTA">FIRE=5
闇=5
サイキック=5
嫌い=5
水=3
死亡=3
重力=3
愛=2
疫病=2
ライフ=2
ライト=1
スピード=1
スピリット=1
無関心=0
メタル=0</テキストエリア>
    <div class="row">
      <button id="saveRatio">レシオを保存</button>
      <span class="small">保存＝ブラウザに永続化。操作は常に現在のフィールドの値で即反映されます。</span>
    </div>
    <div id="ratioView" class="small" style="margin-top:8px;"></div>
  </div>

  <!-- ③ 下段：プロトコル一覧 -->
  <div class="card">
    <div class="small">プロトコル（一覧行ごとに1件）</div>
    <textarea id="pool">死
火
重力
人生
ライト
金属
疫病
サイキック
スピード
精神
暗闇
水</textarea>
    <div class="row">
      <button id="reset">初期化</button>
      <button id="shuffle">表示をシャッフル</button>
      <button id="pick1">1枚ランダム</button>
      <button id="clear">結果クリア</button>
    </div>
    <div id="チップス"></div>
  </div>
</div>

<スクリプト>
/* ---------- 定数/状態 ---------- */
const dMain = ["死","火","重力","生命","光","金属","疫病","超能力","速度","精神","闇","水"];
const auxSet = ["憎しみ","愛","無関心"];
const LS = { プール: "compile.pool"、比率: "compile.ratio"、パラメーター: "compile.params"、補助: "compile.auxExcluded" };
const CP_LINK = "https://princetottino10-bit.github.io/compile-picker/compile_protocol_picker.html";

/* ---------- 要素取得 ---------- */
const poolTA = document.getElementById('pool');
const chips = document.getElementById('chips');
const auxToggle = document.getElementById('auxToggle');
const out = document.getElementById('out');
const ratioTA = document.getElementById('ratioTA');
const ratioView = document.getElementById('ratioView');
const cntIn = document.getElementById('cnt');
const p1MinIn= ドキュメント.getElementById('p1Min');
const p1MaxIn= ドキュメント.getElementById('p1Max');
const p2MinIn= ドキュメント.getElementById('p2Min');
const p2MaxIn= ドキュメント.getElementById('p2Max');
const buildSideSel = document.getElementById('buildSide');

/* ---------- ユーティリティ ---------- */
関数uniq(行){
  const seen=new Set(), arr=[];
  for(const s 行){ const t=(s||"").trim().toUpperCase(); if(t && !seen.has(t)){ seen.add(t); arr.push(t); } }
  arr を返します。
}
関数 getPool(){ return uniq(poolTA.value.split(/\r?\n/)); }
関数 setPool(list){ poolTA.value = list.join("\n"); renderChips(); }
関数 renderChips(){ const pool=getPool(); chips.innerHTML = pool.map(p=>`<span class="pill">${p}`).join(""); }
関数シャッフル(a){ const arr=a.slice(); for(let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]];} return arr; }
関数sample(a,n){ return shuffle(a).slice(0, Math.min(n,a.length)); }
関数parseRatio(テキスト){
  const map = Object.create(null);
  for(const 行 (テキスト||"").split(/\r?\n/)){
    const t=(line||"").trim(); if(!t) 継続;
    const idx=t.indexOf("="); if(idx<0) 継続;
    const k=t.slice(0,idx).trim().toUpperCase();
    const v=Number(t.slice(idx+1).trim());
    if(k && !isNaN(v) && v>=0) マップ[k]=v; // 0許可
  }
  マップを返します。
}
関数 getRatioMap(){ return parseRatio(ratioTA.value); }
関数 costOf(k){ const m=getRatioMap(); 戻り値 m[k] ?? 1; }
関数 showRatioPreview(){
  const プール = getPool()、R = getRatioMap();
  const rows = pool.map(k => `${k}: ${R[k] ?? 1}`);
  rateView.textContent = "最新レシオ → " + rows.join(" / ");
}
関数 saveAll(){
  localStorage.setItem(LS.pool、poolTA.value);
  localStorage.setItem(LS.ratio、ratioTA.value);
  localStorage.setItem(LS.params, JSON.stringify({
    cnt:+cntIn.値、p1min:+p1MinIn.値、p1max:+p1MaxIn.値、
    p2min:+p2MinIn.value、p2max:+p2MaxIn.value、build:buildSideSel.value
  }));
  localStorage.setItem(LS.aux, auxToggle.checked? "1" : "0");
}
関数loadAll(){
  auxToggle.checked = (localStorage.getItem(LS.aux) ?? "0") === "1";
  const poolSaved = localStorage.getItem(LS.pool);
  if(poolSaved){poolTA.value = poolSaved; }
  else{ setPool(dMain.concat(auxSet)); } // 初期はMain+Aux1を含む

  const rSaved = localStorage.getItem(LS.ratio); if(rSaved) ratioTA.value = rSaved;
  定数パラメータ = localStorage.getItem(LS.params);
  if(パラメータ){
    試す{
      const p=JSON.parse(params)||{};
      cntIn.value = p.cnt ?? 3;
      p1MinIn.value = p.p1min ?? 7; p1MaxIn.value = p.p1max ?? 8;
      p2MinIn.value = p.p2min ?? 7; p2MaxIn.value = p.p2max ?? 8;
      if(p.build) buildSideSel.value = p.build;
    }キャッチ(e){}
  }
  // 補助適用
  if(auxToggle.checked){ setPool(getPool().filter(x=>!auxSet.includes(x))); }
  そうでない場合{ const cur=getPool(); const add=auxSet.filter(x=>!cur.includes(x)); if(add.length) setPool(cur.concat(add)); }
  renderChips(); showRatioPreview();
}
関数revealResult(){ out.scrollIntoView({behavior:'smooth', block:'nearest'}); }

/* ---------- 共有：UI と動作 ---------- */
const shareRow = document.getElementById('shareRow');
const shareBtn = document.getElementById('shareBtn');
const コピーボタン = document.getElementById('コピーボタン');
関数 getShareText(){
  txt = (out.textContent || "").trim() とします。
  if(!txt.includes(CP_LINK)) txt += `\n\n🔗 コンパイルピッカー: ${CP_LINK}`;
  txt を返します。
}
関数 updateShareButtons(){
  const has = !!(out.textContent && out.textContent.trim());
  shareRow.style.display = には ? "flex" : "none" があります。
}
shareBtn.onclick = 非同期()=>{
  const テキスト = getShareText();
  試す{
    if(navigator.share){ navigator.share({ text }); }
    else{ await navigator.clipboard.writeText(text); alert("共有APIが使えないため、テキストをコピーしました。"); }
  }catch(e){ console.warn(e); }
};
copyBtn.onclick = 非同期()=>{
  const テキスト = getShareText();
  試す{
    navigator.clipboard.writeText(テキスト) を待機します。
    const old = copyBtn.textContent; copyBtn.textContent = "コピー完了";
    setTimeout(()=> copyBtn.textContent = old, 1200);
  }catch(e){alert("コピーに失敗しました。"); }
};

/* ----------基本操作 ---------- */
document.getElementById('reset').onclick = ()=>{ let list=dMain.slice(); if(!auxToggle.checked) list=list.concat(auxSet); setPool(list); out.textContent=""; saveAll(); showRatioPreview(); updateShareButtons(); };
document.getElementById('shuffle').onclick = ()=>{ setPool(shuffle(getPool())); saveAll(); };
document.getElementById('clear').onclick = ()=>{ out.textContent=""; updateShareButtons(); };
document.getElementById('pick1').onclick = ()=>{ const p=getPool(); out.textContent = p.length?("🎲 1枚ランダム\n"+sample(p,1)[0]):"リストが空です。";明らかに結果(); updateShareButtons(); };
document.getElementById('pick3').onclick = ()=>{ const p=getPool(); const n=+cntIn.value||3; out.textContent = p.length?("🎲 "+n+"枚ランダム（重複なし）\n- "+sample(p,n).join("\n- ")):"リストが空です。";明らかに結果(); updateShareButtons(); };
document.getElementById('saveRatio').onclick = ()=>{ localStorage.setItem(LS.ratio, ratioTA.value); showRatioPreview(); };
auxToggle.addEventListener('change', ()=>{ let l=getPool(); if(auxToggle.checked){ setPool(l.filter(x=>!auxSet.includes(x))); } else { for(const x of auxSet) if(!l.includes(x)) l.push(x); setPool(l); } saveAll(); showRatioPreview(); });
[poolTA、ratioTA、cntIn、p1MinIn、p1MaxIn、p2MinIn、p2MaxIn、buildSideSel].forEach(el=>el.addEventListener('input'、saveAll));

/* 下部固定バー → 既存ボタンをトリガー */
document.getElementById('runDraftRandom').onclick = ()=> document.getElementById('draftRandom').click();
document.getElementById('runDraftRatio').onclick = ()=> document.getElementById('draftRatio').click();
document.getElementById('runBuild').onclick = ()=> document.getElementById('pickRatioBuild').click();

/* ---------- レシオ制：ユーティリティ（高速版） ---------- */
関数enumerateCombos(プール、N、minSum、maxSum、costFn){
  const items = pool.map(k=>({k, c: costFn(k)})).sort((a,b)=>ac-bc);
  const キー = items.map(x=>xk);
  const コスト = items.map(x=>xc);

  const プレフィックス = 新しい配列(costs.length+1).fill(0);
  for(let i=0;i<costs.length;i++) prefix[i+1] = prefix[i] + cost[i];

  定数 res=[];
  const pick = 新しい配列(N);

  関数 rec(開始, 深さ, 合計){
    const 残り = N - 深さ;
    残り>0の場合
      const minTail = prefix[start+remain] - prefix[start];
      if(sum + minTail > maxSum) return; // 上限超え確定→枝刈り
    }
    if(深さ===N){
      if(sum>=minSum && sum<=maxSum) res.push({ set:new Set(pick), arr: pick.slice(), s: sum });
      戻る;
    }
    for(let i=start; i<=keys.length - remain; i++){
      const c = コスト[i];
      if(sum + c > maxSum) ブレーク; //昇順なのでこれ以降もオーバー
      pick[depth] = keys[i];
      rec(i+1, 深さ+1, 合計 + c);
    }
  }
  レコード0, 0, 0;
  res を返します。
}

/* ---------- レシオ制：1人分構築（P1設定 or P2設定で判定） ---------- */
document.getElementById('pickRatioBuild').onclick = ()=>{
  const プール = getPool()、N = + cntIn.value;
  if(pool.length<N){ out.textContent=" プールが足りません（"+N+" 以上必要）。";明らかに結果(); updateShareButtons();戻る; }

  const rateMap = getRatioMap();
  const cost = k => (ratioMap[k] ?? 1);

  const side = buildSideSel.value; // "P1" または "P2"
  const minS = side==="P1" ? +p1MinIn.value : +p2MinIn.value;
  const maxS = side==="P1" ? +p1MaxIn.value : +p2MaxIn.value;

  const combos = enumerateCombos(プール、N、minS、maxS、コスト);
  if(!combos.length){
    const コスト = pool.map(cost).sort((a,b)=>ab);
    const minPossible = コスト.スライス(0, N).reduce((a,b)=>a+b,0);
    const maxPossible = コスト.スライス(-N).削減((a,b)=>a+b,0);
    out.textContent=`条件（${side}設定:合計${minS}〜${maxS} / ${N}枚）に該当する組み合わせは見つかりません。\nヒント：このプール理論上の最小=${minPossible}, 最大=${maxPossible}です。Min/Maxやレシオを見直してください。`;
    revealResult(); updateShareButtons(); 戻り値;
  }

  const pick = combos[Math.floor(Math.random()*combos.length)];
  const は pick.arr.map(k => `${k}(${cost(k)})`).join("\n- "); をリストします。
  out.textContent = `🧮 レシオ制デッキ構築（${side}設定 / ${minS}〜${maxS} / ${N}枚）\n- ${listed}\n合計: ${pick.s}\n\n🔗 コンパイルピッカー: ${CP_LINK}`;
  結果を表示します(); 共有ボタンを更新します();
};

/* ---------- レシオ制：わずか（P1→残りからP2探索） ---------- */
document.getElementById('draftRatio').onclick = ()=>{
  const プール = getPool()、N = + cntIn.value;
  if(pool.length < 2*N){ out.textContent=" プールが少なすぎます（"+(2*N)+" 以上必要）。";明らかに結果(); updateShareButtons();戻る; }

  const rateMap = getRatioMap();
  const cost = k => (ratioMap[k] ?? 1);

  定数 p1Min=+p1MinIn.value、p1Max=+p1MaxIn.value;
  定数 p2Min=+p2MinIn.value、p2Max=+p2MaxIn.value;

  const p1Combos = enumerateCombos(プール、N、p1Min、p1Max、コスト);
  if(!p1Combos.length){ out.textContent=`P1 条件（合計${p1Min}〜${p1Max} / ${N}枚）を満たすセットが見つかりません。`;明らかに結果(); updateShareButtons();戻る; }

  const p1Order = シャッフル(p1Combos);
  best=null とします。
  for(const c1 of p1Order){
    const 残りのプール = pool.filter(x=>!c1.set.has(x));
    もしremainPool.length<Nであれば継続します。
    const p2Combos = enumerateCombos(remainPool、N、p2Min、p2Max、コスト);
    if(p2Combos.length){ best=[c1, p2Combos[Math.floor(Math.random()*p2Combos.length)]]; break; }
  }
  if(!best){ out.textContent="全体的に重複しない 2 セットは作りません。プールや各条件を見直してください。";明らかに結果(); updateShareButtons();戻る; }

  const first = Math.random()<0.5 ? "P1" : "P2"; // 先攻
  定数P1 = best[0].arr.slice()、P2 = best[1].arr.slice();
  const fmt = a => a.map((k,i)=>`${i+1}. ${k}(${cost(k)})`).join("\n");
  const 残り = pool.filter(x=>!P1.includes(x)&&!P2.includes(x));

  out.textContent =
`🌀 レシオ制ドラフト（各${N}枚）
先攻: ${first}

P1合計=${best[0].s}（条件${p1Min}〜${p1Max}）
${fmt(P1)}

P2合計=${best[1].s}（条件${p2Min}〜${p2Max}）
${fmt(P2)}

残りのプール (${remain.length})
- ${remain.join(", ")}

🔗 コンパイルピッカー: ${CP_LINK}`;
  結果を表示します(); 共有ボタンを更新します();
};

/* ---------- 完全ランダム：指名（コスト無視） ---------- */
関数 makeSnakeSequence(nEach){
  const pat=[["P1",1],["P2",2],["P1",2],["P2",1]];
  const rem={P1:nEach, P2:nEach}, seq=[]; i=0 とする;
  while(rem.P1>0 || rem.P2>0){
    const [w,t]=pat[i%pat.length]、take=Math.min(t, rem[w]);
    take>0の場合、seq.push([w,take]); rem[w]-=take; }
    i++; if(i>200) ブレーク;
  }
  seq を返します。
}
document.getElementById('draftRandom').onclick = ()=>{
  const プール = getPool().slice();
  定数 N = +cntIn.value;
  if(pool.length < 2*N){ out.textContent = `プールが足りません（${2*N}以上必要）。`;明らかに結果(); updateShareButtons();戻る; }

  const first = Math.random()<0.5 ? 'P1' : 'P2';
  const bag = shuffle(pool);
  const seq = makeSnakeSequence(N).map(([who,take])=> first==='P1' ? [who,take] : [who==='P1'?'P2':'P1',take]);
  const picks={P1:[],P2:[]};
  for(const [who,take] of seq){ picks[who].push(...bag.splice(0,take)); }

  const fmt = a => a.map((k,i)=>`${i+1}. ${k}`).join("\n");
  out.textContent =
`🎲完全ランダム指名（各${N}枚／コスト無視）
先攻: ${first}

P1
${fmt(picks.P1)}

P2
${fmt(picks.P2)}

残りのプール (${bag.length})
- ${bag.join(", ")}

🔗 コンパイルピッカー: ${CP_LINK}`;
  結果を表示します(); 共有ボタンを更新します();
};

/* ---------- 初期化 ---------- */
if(!localStorage.getItem(LS.ratio)) localStorage.setItem(LS.ratio、document.getElementById('ratioTA').value);
if(!localStorage.getItem(LS.params)){
  ローカルストレージにアイテムを設定するには、LS.params、JSON.stringify({cnt:3、p1min:7、p1max:8、p2min:7、p2max:8、build:"P1"}) を使用します。
}
if(localStorage.getItem(LS.aux)===null) localStorage.setItem(LS.aux,"0");
if(!localStorage.getItem(LS.pool)){
  localStorage.setItem(LS.pool、dMain.concat(auxSet).join("\n"));
}
すべてをロードします();
</スクリプト>

<フッター>
  © 2025 りゅー (@suke69) — <a href="https://x.com/suke69" target="_blank">https://x.com/suke69</a>
</フッター>
