<!doctype html>
<meta charset="utf-8">
<title>Compile Picker</title>
<meta name="author" content="りゅー (@suke69)">
<meta name="description" content="Compile Picker  by りゅー (@suke69)">
<meta property="og:title" content="Compile Picker">
<meta property="og:description" content=" by りゅー (@suke69)">
<meta property="og:url" content="https://x.com/suke69">
<style>
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,"Noto Sans JP","Yu Gothic",Meiryo,Arial,sans-serif;background:#0d1117;color:#e6edf3;margin:24px}
  h1{font-size:20px;margin:0 0 10px}
  .grid{display:grid;grid-template-columns:1fr 1fr;gap:16px}
  .card{background:#111827;border:1px solid #263244;border-radius:12px;padding:12px}
  .row{display:flex;gap:8px;flex-wrap:wrap;margin:8px 0}
  textarea{width:100%;min-height:120px;background:#0b1220;color:#e6edf3;border:1px solid #263244;border-radius:10px;padding:8px}
  input[type="number"],select{background:#0b1220;color:#e6edf3;border:1px solid #263244;border-radius:8px;padding:6px 8px}
  button{background:#1f2937;border:1px solid #2d3a4a;color:#e6edf3;padding:8px 12px;border-radius:10px;cursor:pointer;font-weight:700}
  button:hover{background:#263244}
  .result{white-space:pre-wrap;background:#0b1220;border:1px dashed #2d3a4a;border-radius:10px;padding:10px;min-height:90px;margin-top:8px}
  .small{color:#9aa6b2;font-size:12px}
  .pill{display:inline-block;padding:4px 8px;border:1px solid #2d3a4a;border-radius:999px;margin:4px 6px 0 0}
  .col{flex:1;min-width:240px}
  @media(max-width:1000px){.grid{grid-template-columns:1fr}}
  a.x{color:#58a6ff;text-decoration:none}
  footer{margin-top:30px;text-align:center;color:#9aa6b2;font-size:12px}
</style>

<h1>
  Compile Picker
  <span style="font-size:14px;color:#9aa6b2;font-weight:400;">
    by <a class="x" href="https://x.com/suke69" target="_blank">りゅー (@suke69)</a>
  </span>
</h1>

<div class="grid">
  <!-- プール -->
  <div class="card">
    <div class="row">
      <label class="small"><input type="checkbox" id="auxToggle"> Aux1（HATE/LOVE/APATHY）を除外</label>
      <span class="small">行ごとに1プロトコル。初期は Main+Aux1 を含みます。</span>
    </div>
    <textarea id="pool">DEATH
FIRE
GRAVITY
LIFE
LIGHT
METAL
PLAGUE
PSYCHIC
SPEED
SPIRIT
DARKNESS
WATER</textarea>
    <div class="row">
      <button id="reset">初期化</button>
      <button id="shuffle">表示をシャッフル</button>
      <button id="clear">結果クリア</button>
    </div>
    <div id="chips"></div>
  </div>

  <!-- 抽選＆レシオ -->
  <div class="card">
    <div class="row">
      <button id="pick1">1枚ランダム</button>
      <button id="pick3">3枚（重複なし）</button>
      <button id="draftRatio">レシオ制ドラフト（P1 vs P2）</button>
      <button id="draftRandom">完全ランダムドラフト（P1 vs P2）</button>
    </div>

    <!-- 共通の枚数 + P1/P2個別条件 -->
    <div class="row">
      <label class="small">枚数
        <input type="number" id="cnt" value="3" min="2" max="6" style="width:90px">
      </label>
    </div>
    <div class="row">
      <div class="col small">
        <strong>P1 条件</strong><br>
        合計Min <input type="number" id="minP1" value="7" style="width:80px">
        合計Max <input type="number" id="maxP1" value="8" style="width:80px">
      </div>
      <div class="col small">
        <strong>P2 条件</strong><br>
        合計Min <input type="number" id="minP2" value="7" style="width:80px">
        合計Max <input type="number" id="maxP2" value="8" style="width:80px">
      </div>
    </div>

    <!-- レシオ制の単体構築（どちらの条件を使うか選択） -->
    <div class="row">
      <button id="pickRatioBuild">レシオ制デッキ構築</button>
      <label class="small">対象
        <select id="buildTarget">
          <option value="P1">P1条件を使用</option>
          <option value="P2">P2条件を使用</option>
        </select>
      </label>
    </div>

    <div id="out" class="result"></div>

    <!-- レシオ編集 -->
    <div class="row">
      <div style="flex:1">
        <div class="small">レシオ（初期値＝あなたの設定／0許可）</div>
        <textarea id="ratioTA">FIRE=5
DARKNESS=5
PSYCHIC=5
HATE=5
WATER=3
DEATH=3
GRAVITY=3
LOVE=2
PLAGUE=2
LIFE=2
LIGHT=1
SPEED=1
SPIRIT=1
APATHY=0
METAL=0</textarea>
        <button id="saveRatio">レシオを保存</button>
      </div>
    </div>
    <div id="ratioView" class="small" style="margin-top:8px;"></div>
  </div>
</div>

<script>
/* ---------- 定数/状態 ---------- */
const dMain = ["DEATH","FIRE","GRAVITY","LIFE","LIGHT","METAL","PLAGUE","PSYCHIC","SPEED","SPIRIT","DARKNESS","WATER"];
const auxSet = ["HATE","LOVE","APATHY"];
const LS = {
  pool:"compile.pool",
  ratio:"compile.ratio",
  aux:"compile.auxExcluded",
  params:"compile.params2" // P1/P2個別条件 + N
};

/* ---------- 要素 ---------- */
const poolTA = document.getElementById('pool');
const chips = document.getElementById('chips');
const auxToggle = document.getElementById('auxToggle');
const out = document.getElementById('out');
const ratioTA = document.getElementById('ratioTA');
const ratioView = document.getElementById('ratioView');

const cntIn = document.getElementById('cnt');
const minP1 = document.getElementById('minP1');
const maxP1 = document.getElementById('maxP1');
const minP2 = document.getElementById('minP2');
const maxP2 = document.getElementById('maxP2');
const buildTarget = document.getElementById('buildTarget');

/* ---------- ユーティリティ ---------- */
function uniq(lines){
  const seen=new Set(), arr=[];
  for(const s of lines){ const t=(s||"").trim().toUpperCase(); if(t && !seen.has(t)){ seen.add(t); arr.push(t); } }
  return arr;
}
function getPool(){ return uniq(poolTA.value.split(/\r?\n/)); }
function setPool(list){ poolTA.value = list.join("\n"); renderChips(); }
function renderChips(){ const pool=getPool(); chips.innerHTML = pool.map(p=>`<span class="pill">${p}</span>`).join(""); }
function shuffle(a){ const arr=a.slice(); for(let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]];} return arr; }
function sample(a,n){ return shuffle(a).slice(0, Math.min(n,a.length)); }

function parseRatio(text){
  const map = Object.create(null);
  for(const line of (text||"").split(/\r?\n/)){
    const t=(line||"").trim(); if(!t) continue;
    const idx=t.indexOf("="); if(idx<0) continue;
    const k=t.slice(0,idx).trim().toUpperCase();
    const v=Number(t.slice(idx+1).trim());
    if(k && !isNaN(v) && v>=0) map[k]=v; // 0許可
  }
  return map;
}
function ratioOf(k){
  const R = parseRatio(localStorage.getItem(LS.ratio) || ratioTA.value);
  return R[k] ?? 1;
}
function showRatioPreview(){
  const pool = getPool(); const R = parseRatio(localStorage.getItem(LS.ratio) || ratioTA.value);
  const rows = pool.map(k => `${k}: ${R[k] ?? 1}`);
  ratioView.textContent = "現在のレシオ → " + rows.join(" / ");
}
function saveAll(){
  localStorage.setItem(LS.pool, poolTA.value);
  localStorage.setItem(LS.ratio, ratioTA.value);
  localStorage.setItem(LS.aux, auxToggle.checked ? "1" : "0");
  localStorage.setItem(LS.params, JSON.stringify({
    N:+cntIn.value,
    p1:{min:+minP1.value, max:+maxP1.value},
    p2:{min:+minP2.value, max:+maxP2.value},
    target: buildTarget.value
  }));
}
function loadAll(){
  auxToggle.checked = (localStorage.getItem(LS.aux) ?? "0") === "1";

  const poolSaved = localStorage.getItem(LS.pool);
  if(poolSaved){ poolTA.value = poolSaved; }
  else{ setPool(dMain.concat(auxSet)); } // 初期はMain+Aux1含む

  const rSaved = localStorage.getItem(LS.ratio); if(rSaved) ratioTA.value = rSaved;

  const paramsSaved = localStorage.getItem(LS.params);
  if(paramsSaved){
    try{
      const p = JSON.parse(paramsSaved)||{};
      cntIn.value = p.N ?? 3;
      (p.p1||={}); (p.p2||={});
      minP1.value = p.p1.min ?? 7; maxP1.value = p.p1.max ?? 8;
      minP2.value = p.p2.min ?? 7; maxP2.value = p.p2.max ?? 8;
      buildTarget.value = p.target ?? "P1";
    }catch(e){}
  }

  // Aux適用
  if(auxToggle.checked){
    setPool(getPool().filter(x=>!auxSet.includes(x)));
  }else{
    const cur=getPool(); const add=auxSet.filter(x=>!cur.includes(x));
    if(add.length) setPool(cur.concat(add));
  }
  renderChips(); showRatioPreview();
}

/* ---------- 基本操作 ---------- */
document.getElementById('reset').onclick = ()=>{
  let list = dMain.slice();
  if(!auxToggle.checked) list = list.concat(auxSet);
  setPool(list); out.textContent=""; saveAll(); showRatioPreview();
};
document.getElementById('shuffle').onclick = ()=>{ setPool(shuffle(getPool())); saveAll(); };
document.getElementById('clear').onclick = ()=> out.textContent="";
document.getElementById('pick1').onclick = ()=>{ const p=getPool(); out.textContent = p.length?("🎲 1枚ランダム\n"+sample(p,1)[0]):"リストが空です。"; };
document.getElementById('pick3').onclick = ()=>{ const p=getPool(); out.textContent = p.length?("🎲 3枚（重複なし）\n- "+sample(p,3).join("\n- ")):"リストが空です。"; };
document.getElementById('saveRatio').onclick = ()=>{ localStorage.setItem(LS.ratio, ratioTA.value); saveAll(); showRatioPreview(); };

auxToggle.addEventListener('change', ()=>{
  let l=getPool();
  if(auxToggle.checked){ setPool(l.filter(x=>!auxSet.includes(x))); }
  else{ for(const x of auxSet) if(!l.includes(x)) l.push(x); setPool(l); }
  saveAll(); showRatioPreview();
});
poolTA.addEventListener('input', ()=>{ renderChips(); saveAll(); showRatioPreview(); });
[cntIn, minP1, maxP1, minP2, maxP2, buildTarget].forEach(el=>el.addEventListener('input', saveAll));

/* ---------- 組合せ列挙（N枚・合計範囲） ---------- */
function combosBySum(pool, N, cost, minS, maxS){
  const res=[];
  function rec(start, acc, sum){
    if(acc.length===N){ if(sum>=minS && sum<=maxS) res.push({arr:acc.slice(), set:new Set(acc), s:sum}); return; }
    for(let i=start;i<pool.length;i++){
      const k=pool[i]; const next=sum+cost(k);
      // 早期枝刈りはしない（値域が狭いのでOK）
      acc.push(k); rec(i+1, acc, next); acc.pop();
    }
  }
  rec(0, [], 0);
  return res;
}

/* ---------- レシオ制：単体構築 ---------- */
document.getElementById('pickRatioBuild').onclick = ()=>{
  const pool = getPool(), N=+cntIn.value;
  if(pool.length<N){ out.textContent="プールが少なすぎます（"+N+"以上必要）。"; return; }
  const useP = buildTarget.value==="P2" ? {min:+minP2.value, max:+maxP2.value, label:"P2"} : {min:+minP1.value, max:+maxP1.value, label:"P1"};
  const cost = k => ratioOf(k);

  const combos = combosBySum(pool, N, cost, useP.min, useP.max);
  if(!combos.length){ out.textContent=`条件（${useP.label}: 合計${useP.min}〜${useP.max} / ${N}枚）に合う組み合わせが見つかりません。レシオやプールを見直してください。`; return; }
  const pick = combos[Math.floor(Math.random()*combos.length)];
  const listed = pick.arr.map(k => `${k}(${cost(k)})`).join("\n- ");
  out.textContent = `🧮 レシオ制デッキ構築（${useP.label}条件 / ${useP.min}〜${useP.max} / ${N}枚）\n- ${listed}\n合計: ${pick.s}`;
};

/* ---------- レシオ制：ドラフト（P1/P2別条件） ---------- */
document.getElementById('draftRatio').onclick = ()=>{
  const pool = getPool(), N=+cntIn.value;
  if(pool.length < 2*N){ out.textContent="プールが少なすぎます（"+(2*N)+"以上必要）。"; return; }
  const cost = k => ratioOf(k);
  const c1 = combosBySum(pool, N, cost, +minP1.value, +maxP1.value);
  const c2 = combosBySum(pool, N, cost, +minP2.value, +maxP2.value);
  if(!c1.length){ out.textContent="P1条件を満たす組が見つかりません。"; return; }
  if(!c2.length){ out.textContent="P2条件を満たす組が見つかりません。"; return; }

  // 重複しない2組を探索（ランダム順）
  const a = shuffle(c1), b = shuffle(c2);
  let best=null;
  outer: for(const x of a){
    for(const y of b){
      let ok=true; for(const k of x.set){ if(y.set.has(k)){ ok=false; break; } }
      if(ok){ best=[x,y]; break outer; }
    }
  }
  if(!best){ out.textContent="互いに重複しない2セットが作れません。プールや条件を見直してください。"; return; }

  const first = Math.random()<0.5 ? "P1" : "P2";
  const P1 = best[0].arr.slice(), P2 = best[1].arr.slice();
  const fmt = a => a.map((k,i)=>`${i+1}. ${k}(${cost(k)})`).join("\n");
  const remain = pool.filter(x=>!P1.includes(x) && !P2.includes(x));

  out.textContent =
`🌀 レシオ制ドラフト（各${N}枚）
先行: ${first}
P1条件: 合計${minP1.value}〜${maxP1.value} / P2条件: 合計${minP2.value}〜${maxP2.value}
ドラフト順: P1→P2×2→P1×2→P2

P1 合計=${best[0].s}
${fmt(P1)}

P2 合計=${best[1].s}
${fmt(P2)}

残りプール (${remain.length})
- ${remain.join(", ")}`;
};

/* ---------- 完全ランダム：ドラフト（コスト無視） ---------- */
function makeSnakeSequence(nEach){
  const pat=[['P1',1],['P2',2],['P1',2],['P2',1]];
  const rem={P1:nEach, P2:nEach}, seq=[]; let i=0;
  while(rem.P1>0 || rem.P2>0){
    const [w,t]=pat[i%pat.length], take=Math.min(t, rem[w]);
    if(take>0){ seq.push([w,take]); rem[w]-=take; }
    i++; if(i>200) break;
  }
  return seq;
}
document.getElementById('draftRandom').onclick = ()=>{
  const pool = getPool().slice();
  const N = +cntIn.value;
  if(pool.length < 2*N){ out.textContent = `プールが少なすぎます（${2*N}以上必要）。`; return; }

  const first = Math.random()<0.5 ? 'P1' : 'P2';
  const bag = shuffle(pool);
  const seq = makeSnakeSequence(N).map(([who,take])=> first==='P1' ? [who,take] : [who==='P1'?'P2':'P1',take]);
  const picks={P1:[],P2:[]};
  for(const [who,take] of seq){ picks[who].push(...bag.splice(0,take)); }

  const fmt = a => a.map((k,i)=>`${i+1}. ${k}`).join("\n");
  out.textContent =
`🎲 完全ランダムドラフト（各${N}枚／コスト無視）
先行: ${first}
ドラフト順: P1→P2×2→P1×2→P2

P1
${fmt(picks.P1)}

P2
${fmt(picks.P2)}

残りプール (${bag.length})
- ${bag.join(", ")}`;
};

/* ---------- 初期化 ---------- */
if(!localStorage.getItem(LS.ratio)) localStorage.setItem(LS.ratio, document.getElementById('ratioTA').value);
if(localStorage.getItem(LS.aux)===null) localStorage.setItem(LS.aux,"0");
if(!localStorage.getItem(LS.pool)){
  localStorage.setItem(LS.pool, dMain.concat(auxSet).join("\n"));
}
if(!localStorage.getItem(LS.params)){
  localStorage.setItem(LS.params, JSON.stringify({N:3,p1:{min:7,max:8},p2:{min:7,max:8},target:"P1"}));
}
loadAll();
</script>

<footer>
  © 2025 りゅー (@suke69) — <a class="x" href="https://x.com/suke69" target="_blank">https://x.com/suke69</a>
</footer>
